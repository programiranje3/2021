"""Domain classes and functions related to the concept of song.
"""


# from util import utility
from music.enums import *
import json


class Song:
    """The class describing the concept of song.
    It is assumed that a song is sufficiently described by its
    title and whether it is "unplugged" song or not.

    This class illustrates some of the important concepts of Python classes:
    - self
    - __init__()
    - __str__()
    - __eq__(self, other) is the equivalent of Java equals() and should be overridden in classes
    - __dict__ attribute of all objects
    - data fields (instance variables)
    - methods - calling them by self.<method>(...) from the same class where they are defined
    """

    def __init__(self, title, is_unplugged=False):
        self.title = title
        self.is_unplugged = is_unplugged
        # self.__n = 'kkk'                                    # 'private' field
        # self._n = 'lll'                                     # 'protected' field

    # Properties: 'private' fields:
    #   @property
    #   def <attr>(self):
    #       return self.__<attr>
    #   @<attr>.setter
    #   def <attr>(self, <attr>):
    #       self.__<attr> = <attr> if ... else ...
    # Run setters and getters in the debugger.
    # Make title a property (after setting up __init__(), __str__(), __eq__(), methods,...).

    @property
    def title(self):
        return self.__title

    @title.setter
    def title(self, title):
        self.__title = title if isinstance(title, str) else 'unknown'

    # Add an immutable property (no setter for it) - just return self; prints as __str__().

    def __str__(self):
        return f'{self.title}' if not self.is_unplugged else f'{self.title} (unplugged)'

    def __eq__(self, other):
        isi = isinstance(other, Song)
        t = self.title == other.title
        u = self.is_unplugged == other.is_unplugged
        return isi and t and u

    def play(self, artist, *args, **kwargs):
        """Assumes that artist, *args (e.g. expressions of gratitude) and kwargs.values() (e.g. messages) are strings.
        Prints song title, artist, and things like rhythm counts, expressions of gratitude and messages. A call example:
            <song>.play(artist, *['Thank you!', 'You're wonderful!], love='We love you!')
        """

        # print(f'{self.title} ({artist})')
        print(self.title)
        print(artist)
        if args:
            print(f'{", ".join([str(arg) for arg in args])}')
        if kwargs:
            print(f'{", ".join([str(k) + ": " + str(v) for k, v in kwargs.items()])}')

    def play_song(self, artist, *args, **kwargs):
        """Demonstrates calling another method from the same class (self.<method>(...) as a mandatory syntax).
        """

        self.play(artist, *args, **kwargs)

    # Alternative constructor
    @classmethod
    def from_str(cls, song_string):
        """Inverted __str__() method.
        Assumes that song_string is in the format generated by __str__().
        """

        # return f'{self.title}' if not self.is_unplugged else f'{self.title} (unplugged)'
        t = song_string.split(' (unplugged)')[0]
        u = True if song_string.endswith(' (unplugged)') else False
        return cls(t, u)


class SongEncoder(json.JSONEncoder):
    """JSON encoder for Song objects (cls= parameter in json.dumps()).
    """

    def default(self, song):
        # recommendation: always use double quotes with JSON

        pass
        # can simply return song_py_to_json(song), to avoid code duplication


def song_py_to_json(song):
    """JSON encoder for Song objects (default= parameter in json.dumps()).
    """

    # recommendation: always use double quotes with JSON
    pass


def song_json_to_py(song_json):
    """JSON decoder for Song objects (object_hook= parameter in json.loads()).

    It is essential to run this code in the debugger. If the breakpoint is set at the very first line (the if statement)
    it is possible to see that, internally, this function runs TWICE per call (!!!) -
    the first time the if statement evaluates to False because the first time song_json does not include "__Song__" (!),
    and the return song_json actually does not return to the calling point but to some idiosyncratic Python functions
    that do some internal witchcraft; when they are done, this function resurrects at the if statement again and
    suddenly song_json DOES include "__Song__" and everything works fine (!?!?!).
    """

    pass


class Ballad(Song):
    """The class describing the concept of ballad.
    It is assumed that a ballade is sufficiently described as a Song,
    with the addition of whether its tempo is slow or moderate.

    Useful link (related to inheritance in Python):
    https://stackoverflow.com/questions/3394835/use-of-args-and-kwargs/3394902#3394902 (calling super() in constructors)
    """

    # # Version 1 - no multiple inheritance
    # def __init__(self, title, is_unplugged=False, tempo=Tempo.SLOW):
    #     super().__init__(title, is_unplugged)
    #     self.tempo = tempo

    # Version 2 - with multiple inheritance
    def __init__(self, tempo=Tempo.SLOW, **kwargs):
        super().__init__(**kwargs)
        self.tempo = tempo

    def __str__(self):
        return super().__str__() + '; ballad'

    def __eq__(self, other):
        # Recommended if inheritance is involved
        # (https://stackoverflow.com/questions/390250/elegant-ways-to-support-equivalence-equality-in-python-classes):
        # if type(other) is type(self):
        #     return self.__dict__ == other.__dict__
        # return False

        return self.__dict__ == other.__dict__ if type(self) is type(other) else False

    def play(self, artist, *args, **kwargs):
        """Assumes that artist, *args (e.g. expressions of gratitude) and kwargs.values() (e.g. messages) are strings.
        Prints song title, artist, and things like rhythm counts, expressions of gratitude and messages. A call example:
            <song>.play(artist, *['Thank you!', 'You're wonderful!], love='We love you!')
        """

        super().play(artist, *args, **kwargs)
        print('ballad')


class PianoSong(Song):
    """The class describing the concept of piano song.
    It is assumed that a piano song is sufficiently described as a song
    in which the dominating instrument is piano.
    """

    # # Version 1 - no multiple inheritance
    # def __init__(self, title, is_unplugged=False, instrument=Instrument.PIANO):
    #     super().__init__(title, is_unplugged)
    #     self.instrument = instrument

    # Version 2 - with multiple inheritance
    def __init__(self, instrument=Instrument.PIANO, **kwargs):
        super().__init__(**kwargs)
        self.instrument = instrument

    def __str__(self):
        return super().__str__() + '; piano song'

    def __eq__(self, other):
        # Recommended if inheritance is involved
        # (https://stackoverflow.com/questions/390250/elegant-ways-to-support-equivalence-equality-in-python-classes):
        # if type(other) is type(self):
        #     return self.__dict__ == other.__dict__
        # return False

        return self.__dict__ == other.__dict__ if type(self) is type(other) else False

    def details(self):
        """Just a simple method to indicate details of a piano song.
        """

        print(f'{self.title} is a nice {self.instrument.name.lower()} song.')


class PianoBallad(Ballad, PianoSong):
# class PianoBallad(PianoSong, Ballad, ):
    """The class describing the concept of piano ballade.
    It is assumed that a piano ballade is sufficiently described as a song that is simultaneously piano-dominated.

    Useful links :
    https://stackoverflow.com/a/50465583/1899061 (designing classes (i.e. their __init__() methods) for multiple inh.)
    https://stackoverflow.com/a/533675/1899061 (mixins explained, and what good they are in multiple inheritance)
    """

    def __init__(self, **kwargs):
        super().__init__(**kwargs)

    def __str__(self):
        return super().__str__()

    def __eq__(self, other):
        # Recommended if inheritance is involved
        # (https://stackoverflow.com/questions/390250/elegant-ways-to-support-equivalence-equality-in-python-classes):
        # if type(other) is type(self):
        #     return self.__dict__ == other.__dict__
        # return False

        return self.__dict__ == other.__dict__ if type(self) is type(other) else False


if __name__ == "__main__":

    # from testdata.songs import *

    # Print objects
    # imagine = Song('Imagine')
    imagine = Song('Imagine', True)
    print(imagine)
    print()

    # Compare objects
    print(imagine == Song('Imagine'))
    print()

    # Access data fields (instance variables), including 'private' fields
    print(imagine.title)
    imagine.title = 'Imagine'
    print(imagine.title)
    imagine.is_unplugged = False
    print(imagine.is_unplugged)
    print()
    # print(imagine._n)
    # # print(imagine.__n)
    # print(imagine._Song__n)
    # print()

    # Add new data fields (instance variables)
    #   1. <object>.<new_attr> = <value>
    #   2. <object>.__setattr__('<new_attr>', <value>)      # counterpart: <object>.__getattribute__('<attr>')
    #   3. setattr(<object>, '<new_attr>', <value>))        # counterpart: getattr(<object>, '<attr>')
    imagine.year = 1971
    print(imagine.year)
    print()

    # Calling methods
    imagine.play('John Lennon')
    imagine.play_song('John Lennon')
    print()

    # Demonstrate object data fields and methods in Python Console for some built-in classes (boolean, int, object,...)
    # - True + 1
    # - True.__int__()
    # - (1).__class__.__name__
    # - (1).__class__
    # - o.__dir__()
    # - o.__dir__
    # - o.__dict__

    # Demonstrate object data fields and methods for Song objects
    print(imagine.__dir__())
    print(imagine.__dict__)
    print()

    # Demonstrate @classmethod (from_str())
    s = imagine.__str__()
    # im2 = imagine.from_str(s)
    im2 = Song.from_str(s)
    print(im2)
    print()

    # Demonstrate inheritance
    # object class
    #   it's like the Object class in Java
    #   all classes inherit from object - try, e.g., list.__mro__ in the console
    #   object class defines object.__eq__(self, other) etc.
    #   object.__ne__(self, other), the inverse of object.__eq__(self, other),
    #   is provided by Python automatically once object.__eq__(self, other) is implemented
    right_before_my_eyes = Ballad(title='Right Before My Eyes', is_unplugged=True, )
    print(right_before_my_eyes)
    print(right_before_my_eyes == Ballad(title='Right Before My Eyes', is_unplugged=True, ))
    print()
    let_it_be = PianoSong(title='Let It Be', )
    print(let_it_be)
    print(let_it_be == PianoSong(title='Let It Be', ))
    print()

    # Demonstrate method overriding
    print()

    # Demonstrate multiple inheritance and MRO.
    # Make sure to read this first: https://stackoverflow.com/a/50465583/1899061 (especially Scenario 3).
    jealous_guy = PianoBallad(title='Jelous Guy', is_unplugged=False, tempo=Tempo.MODERATE, instrument=Instrument.PIANO)
    print(jealous_guy)
    print(PianoBallad.__mro__)
    print()

    # Demonstrate JSON encoding/decoding of simple data types.
    # Refer to https://docs.python.org/3.3/library/json.html#encoders-and-decoders for details.
    print()

    # Demonstrate JSON encoding/decoding of Musician objects
    # Single object
    print()

    # List of objects
    print()

